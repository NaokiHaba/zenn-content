{
  "title": "詳解Go言語Webアプリケーション開発の読書メモ",
  "closed": false,
  "archived": false,
  "created_at": "2023-01-22",
  "comments": [
    {
      "author": "naonao70",
      "created_at": "2023-01-22",
      "body_markdown": "https://gist.github.com/knsh14/0507b98c6b62959011ba9e4c310cd15d\n\nhttps://www.amazon.co.jp/%E8%A9%B3%E8%A7%A3Go%E8%A8%80%E8%AA%9EWeb%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E9%96%8B%E7%99%BA-%E6%B8%85%E6%B0%B4%E9%99%BD%E4%B8%80%E9%83%8E-ebook/dp/B0B62K55SL",
      "body_updated_at": "2023-01-22"
    },
    {
      "author": "naonao70",
      "created_at": "2023-01-22",
      "body_markdown": "##  2章\n\n## contextパッケージについて\n\n> Go言語において、Contextパッケージは、goroutine間での引き継ぎやタイムアウトなどのために使用されます。\n>\n> これは、関数呼び出しのために上下文情報を渡すことができる統一的なインターフェースを提供します。\n>\n> これにより、関数が呼び出される際に必要な情報を持ち回ることができ、その関数が実行される際の環境を調整することができます。\n\n## contextパッケージの構造\n\n- `context`パッケージの操作は、呼び出し元へ伝播されることはない。\n    - 自分が呼び出す関数に渡すだけで、呼び出し元には影響しない。\n    - つまり、呼び出し元のコンテキストを変更することはできない。\n    - ただし、`context`パッケージの操作は、呼び出し元のコンテキストを変更することはできないが、呼び出し元のコンテキストを参照することはできる。\n\n\n\n### サンプル\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t// コンテキストを作成\n\tctx := context.Background()\n\n\t// コンテキストに値を設定\n\tctx = context.WithValue(ctx, \"userID\", \"12345\")\n\n\t// 関数にコンテキストを渡して呼び出す\n\tfmt.Println(process(ctx))\n}\n\nfunc process(ctx context.Context) string {\n\t// コンテキストから値を取得\n\tuserID := ctx.Value(\"userID\").(string)\n\treturn \"Hello, \" + userID\n}\n```\n\n### なぜ使うのか？\n\n> 例えば、HTTPリクエストを受け取った際に、そのリクエストに対してタイムアウトを設定したい場合などに、Contextパッケージを使用することができます。\n>\n> また、goroutine間での引き継ぎなどにも使用することができます。\n>\n> これは、goroutineが実行される際に、そのgoroutineが実行される環境を調整することができるためです。\n\n### キャンセル通知\n\n- `ctx.Err()` でキャンセルのエラーを取得できる\n- `context.WithCancel()` でキャンセル可能なコンテキストを作成できる\n- `context.Background()` でキャンセル不可能なコンテキストを作成できる\n\n```go\nfunc child(ctx context.Context) {\n\t// ctx.Err() は親のコンテキストのエラーを返す\n\tif err := ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tfmt.Println(\"キャンセルされていません\")\n}\n\nfunc main() {\n\t// Hello, 12345\n\tsampleContext()\n\n\t// WithCancel でキャンセル可能なコンテキストを作成\n\t// context.Background() で親のコンテキストを作成\n\tctx, cancel := context.WithCancel(context.Background())\n\t// キャンセルされていません\n\tchild(ctx)\n\n\tcancel()\n\n\t// nil\n\tchild(ctx)\n}\n```\n\n### 指定した時刻を経過したらキャンセル\n\n- `context.WithTimeout` で指定した時刻を経過したらキャンセルするコンテキストを作成できる\n- `select` で `ctx.Done()` と `time.After()` を使う\n    - `ctx.Done()` はキャンセルされたらチャネルに値が入る\n    - `time.After()` は指定した時刻を経過したらチャネルに値が入る\n    - どちらかが先に値が入ったら `select` が終了する\n- `case <-ctx.Done()` でキャンセルされたかどうかを確認できる\n\n```go\nfunc sampleTimeout() {\n\t// WithTimeout で指定し時た間でキャンセル可能なコンテキストを作成\n\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n\n\tdefer cancel()\n\n\t// ctx.Doneチャネルからのシグナルを待つ\n\tselect {\n\t// ctx.Done() とは、キャンセルされたときにシグナルを送るチャネル\n\t// doneチャネルがcloseされたら、caseが実行される\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"タイムアウトしました\")\n\t}\n}\n```\n\n### 指定した時間を経過したらキャンセル\n\n- `context.WithDeadline` で指定した時刻を経過したらキャンセルするコンテキストを作成できる\n- `select` で `ctx.Done()` と `time.After()` を使う\n    - `ctx.Done()` はキャンセルされたらチャネルに値が入る\n    - `time.After()` は指定した時刻を経過したらチャネルに値が入る\n    - どちらかが先に値が入ったら `select` が終了する\n\n```go\nfunc sampleDeadline() {\n\t// WithDeadline で指定した時刻にキャンセル可能なコンテキストを作成\n\tctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(1*time.Second))\n\n\tdefer cancel()\n\n\t// ctx.Doneチャネルからのシグナルを待つ\n\tselect {\n\t// ctx.Done() とは、キャンセルされたときにシグナルを送るチャネル\n\t// doneチャネルがcloseされたら、caseが実行される\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"タイムアウトしました\")\n\t}\n}\n```\n\n### キャンセルされるまで別ゴルーチンからの通知を待つ\n\n```go\n// キャンセルされるまで待つ\nfunc sampleWait() {\n\t// WithTimeout で指定し時た間でキャンセル可能なコンテキストを作成\n\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond)\n\tdefer cancel()\n\n\t// go func で別のgoroutineで実行\n\tgo func() {\n\t\tfmt.Println(\"別のgoroutineで実行\")\n\t}()\n\n\tfmt.Println(\"Stop\")\n\t// ctx.Doneチャネルからのシグナルを待つ\n\t<-ctx.Done()\n\tfmt.Println(\"Done\")\n}\n```\n\n### キャンセルされるまで別処理を繰り返す\n\n- `make(chan int)` でチャネルを作成\n- `case <-ctx.Done():` でキャンセルされたら `break` でループを抜ける\n- `case i := <-task:` で別処理からの通知を待つ\n- `task <- i` で別処理に通知する\n\n```go\nfunc sampleSelect() {\n\tctx, cancel := context.WithCancel(context.Background())\n\n\t// make(chan int) でチャネルを作成\n\ttask := make(chan int)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t\t// i:= <-task でチャネルから値を受け取る\n\t\t\tcase i := <-task:\n\t\t\t\tfmt.Println(i)\n\t\t\tdefault:\n\t\t\t\tfmt.Println(\"キャンセルされていない\")\n\t\t\t}\n\t\t\ttime.Sleep(300 * time.Millisecond)\n\t\t}\n\t}()\n\n\t// time.Sleep(time.Second) で1秒待つ\n\ttime.Sleep(time.Second)\n\n\tfor i := 0; i < 5; i++ {\n\t\t// task <- i でチャネルに値を送る\n\t\ttask <- i\n\t}\n\n\tcancel()\n}\n```\n\n### contextにデータを含める\n\n- `context.WithValue` でキーと値を指定してコンテキストを作成できる\n- `context.Value` でキーを指定して値を取得できる\n\n```go\nfunc sampleWithValue(ctx context.Context, tID TraceID) context.Context {\n    // context.WithValue でコンテキストに値を設定\n    return context.WithValue(ctx, traceIDKey{}, tID)\n    }\n    \n    func sampleGetValue(ctx context.Context) TraceID {\n    // context.Value でコンテキストから値を取得\n    if tID, ok := ctx.Value(traceIDKey{}).(TraceID); ok {\n    return tID\n    }\n    return ZeroTraceID\n}\n\nfunc main() {\n    ctx := context.Background()\n    fmt.Printf(\"TraceID: %q\\n\", sampleGetValue(ctx))\n    \n    ctx = sampleWithValue(ctx, \"12345\")\n    fmt.Printf(\"TraceID: %q\\n\", sampleGetValue(ctx))\n\t\n\t// TraceID: \"\"\n\t// TraceID: \"12345\"\n}\n```\n\n### コンテキストを生成\n\n```go\n// context.Todo\nfunc sampleTodo() {\n\t// context.TODO でコンテキストを作成\n\tctx := context.TODO()\n\tfmt.Println(ctx)\n}\n```",
      "body_updated_at": "2023-01-22"
    }
  ]
}