{
  "title": "実用Go言語 読書メモ",
  "closed": false,
  "archived": false,
  "created_at": "2023-01-15",
  "comments": [
    {
      "author": "naonao70",
      "created_at": "2023-01-15",
      "body_markdown": "\nhttps://www.oreilly.co.jp/books/9784873119694/\n\n知らないこと・気になったことを整理してまとめていく",
      "body_updated_at": "2023-01-22"
    },
    {
      "author": "naonao70",
      "created_at": "2023-01-15",
      "body_markdown": "# 2章\n\n## 型情報\n\nhttps://pkg.go.dev/reflect\n\n- `reflect.TypeOf` は型を返す\n- `typeof Elem()` はポインタ型の要素型を返す\n- `fileType.Implements(writerType)` は `fileType` が `io.Writer` を実装しているかを返す\n\n```go\n\t// int\n\tfmt.Println(reflect.TypeOf(1))\n\t// string\n\tfmt.Println(reflect.TypeOf(\"string\"))\n\t// []int\n\tfmt.Println(reflect.TypeOf([]int{1, 2, 3}))\n\t// map[string]int\n\tfmt.Println(reflect.TypeOf(map[string]int{\"one\": 1, \"two\": 2}))\n\t// func()\n\tfmt.Println(reflect.TypeOf(func() {}))\n\n\t// io.Writer\n\tfmt.Println(reflect.TypeOf(io.Writer(os.Stdout)))\n\n\t// typeof Elem() はポインタ型の要素型を返す\n\twriterType := reflect.TypeOf((*io.Writer)(nil)).Elem()\n\n\tfileType := reflect.TypeOf((*os.File)(nil))\n\n\t// fileType.Implements(writerType) は fileType が io.Writer を実装しているかを返す\n\tfmt.Println(fileType.Implements(writerType))\n```\n\n## 型の拡張\n\n> Values maps a string key to a list of values. It is typically used for query parameters and form values. Unlike in the http.Header map, the keys in a Values map are case-sensitive.\n\nValues は、文字列のキーと値のリストを対応付けます。これは通常、クエリパラメータやフォームの値に使用されます。http.Headerマップとは異なり、Valuesマップのキーは大文字と小文字が区別されます。\n\n```go\nfunc makeMap() {\n\t// 1. make関数を使う\n\t// url.Valuesはmap[string][]stringのエイリアスなのでmake関数で初期化\n\tvs := make(url.Values)\n\tvs.Add(\"key1\", \"value1\")\n\tvs.Add(\"key2\", \"value2\")\n\tfor k, v := range vs {\n\t\tfmt.Printf(\"%s: %v\\n\", k, v)\n\t}\n\n\t// 2. mapリテラルを使う\n\t// mapリテラルで初期化するとmap[string][]stringの型が推論される\n\tvs2 := url.Values{\n\t\t\"key1\": {\"value1\"},\n\t\t\"key2\": {\"value2\"},\n\t}\n\n\tlog.Println(vs, vs2)\n}\n```\n\n## 出力制御\n\nこの記事が分かりやすかった\n\nhttps://budougumi0617.github.io/2019/10/12/confirm-print-with-fmt-interfaces/\n\n```go\ntype ConfidentialCustomer struct {\n\tCustomerID int64\n\tCreditCard CreditCard\n}\n\ntype CreditCard string\n\n// Stringerインターフェースを実装しているので、fmt.Println(c)で呼ばれる\n// StringerインターフェースはfmtパッケージのString()メソッドを実装している\nfunc (c CreditCard) String() string {\n\treturn \"xxxx-xxxx-xxxx-xxxx\"\n}\n\n// GoString GoStringはfmtパッケージのGoString()メソッドを実装している\nfunc (c CreditCard) GoString() string {\n\treturn \"xxxx-xxxx-xxxx-xxxx\"\n}\n\nfunc main() {\n\t// 構造体の初期化\n\tc := ConfidentialCustomer{\n\t\tCustomerID: 1,\n\t\tCreditCard: \"4111-1111-1111-1111\",\n\t}\n\n\tfmt.Println(c)\n\n\t// %v は構造体のフィールド名を表示しない\n\tfmt.Printf(\"%v\\n\", c)\n\n\t// %+v は構造体のフィールド名を表示する\n\tfmt.Printf(\"%+v\\n\", c)\n\n\t// %#v は構造体のフィールド名と型を表示する\n\tfmt.Printf(\"%#v\\n\", c)\n\n\t// JSONに変換\n\tbytes, _ := json.Marshal(c)\n\n\t// JSONを出力\n\tfmt.Println(\"JSON: \", string(bytes)) // 元通り利用可能\n}\n\n```",
      "body_updated_at": "2023-01-15"
    },
    {
      "author": "naonao70",
      "created_at": "2023-01-22",
      "body_markdown": "## 3章\n\n### ファクトリー関数\n\n```go\ntype Author struct {\n\tFirstName string\n\tLastName  string\n}\n\ntype Book struct {\n\tTitle      string\n\tAuthor     Author\n\tPublisher  string\n\tReleasedAt time.Time\n}\n\n// NewAuthor creates a new Author factory\n// ファクトリー関数は、構造体の初期化を行う関数\n// この関数を使うことで、構造体の初期化を隠蔽できる\n// また、構造体の初期化を行うロジックを変更するときに、\n// この関数を変更するだけで済む\nfunc NewAuthor(firstName, lastName string) *Author {\n\treturn &Author{\n\t\tFirstName: firstName,\n\t\tLastName:  lastName,\n\t}\n}\n```\n\n### 構造体にメソッドを定義する\n\n```go\n// NewStruct creates a new Struct factory\nfunc NewStruct(v int) *Struct {\n\treturn &Struct{\n\t\tv: v,\n\t}\n}\n\n// PrintStatus prints the status of the struct\n// メソッドは、構造体のメソッドレシーバーを指定する\n// メソッドレシーバーは、構造体のポインターを指定する\n// これにより、構造体の値を変更できる\n// インスタンスのレシーバーを指定すると、値渡しになる\n// そのため、構造体の値を変更できない\nfunc (s *Struct) PrintStatus() {\n\tlog.Println(\"struct\", s.v)\n}\n```\n\n### 構造体の埋め込みで共通部分を使い回す\n\n```go\ntype UrlBook struct {\n\tTitle string\n\t// ISBNとは、国際標準図書番号のこと\n\tISBN string\n}\n\nfunc (b UrlBook) GetAmazonURL() string {\n\treturn \"https://amazon.co.jp/dp/\" + b.ISBN\n}\n\ntype OraillyBook struct {\n\tUrlBook\n\tISBN13 string\n}\n\nfunc (o OraillyBook) GetOraillyURL() string {\n\treturn \"https://orailly.co.jp/dp/\" + o.ISBN13\n}\n\nfunc main() {\n\tob := OraillyBook{\n\t\tUrlBook: UrlBook{\n\t\t\tTitle: \"Mithril\",\n\t\t\tISBN:  \"4873119030\",\n\t\t},\n\t\tISBN13: \"9784873119030\",\n\t}\n\n\tlog.Println(ob.GetAmazonURL())\n\tlog.Println(ob.GetOraillyURL())\n}\n```\n\n### 構造体にデータを書き込む\n\n構造体にデータを書き込むには、構造体のインスタンスを作成し、そのインスタンスに対してフィールドに値を代入します。\n\n- `reflect.ValueOf` は、インターフェースの値を受け取り、その値の `reflect.Value` を返します。`reflect.Value` は、値の実行時の型と値を表します。\n    - `reflect.Value` は、値の実行時の型を調べるために使われます。\n- `reflect.Elem` は、ポインタの値を受け取り、そのポインタが指す値の `reflect.Value` を返します。\n\n```go\nfunc Decode(target interface{}, src map[string]string) error {\n\t// reflect.ValueOfは、インターフェースの値を返す\n\tv := reflect.ValueOf(target)\n\n\t// .Elem()は、ポインターの値を返す\n\te := v.Elem()\n\n\treturn decode(e, src)\n}\n```\n\n- `reflect.Value.Type()` は、値の実行時の型を返します。\n- `reflect.Value.NumField()` は、構造体のフィールド数を返します。\n- `reflect.Value.Anonymous` は、フィールドが匿名フィールドかどうかを返します。\n    - 匿名フィールドとは、構造体のフィールドに構造体を埋め込むことです。\n        - 例えば、以下のように `Person` 構造体のフィールドに `Name` 構造体を埋め込むことができます。\n            ```go\n            type Person struct {\n                Name\n                Age int\n            }\n            ```\n        - この場合、`Person` 構造体のフィールドは `Name` 構造体のフィールドと `Age` フィールドの2つになります。\n- `reflect.Value.Field()` は、構造体のフィールドの値を返します。\n\n```go\nfunc decode(e reflect.Value, src map[string]string) error {\n\t// reflect.Value.Type()は、型を返す\n\tt := e.Type()\n\n\t// reflect.Value.NumField()は、フィールドの数を返す\n\tfor i := 0; i < t.NumField(); i++ {\n\n\t\t// reflect.Value.Field()は、フィールドの値を返す\n\t\tf := t.Field(i)\n\n\t\t// .Anonymousは、埋め込みフィールドかどうかを返す\n\t\tif f.Anonymous {\n\t\t\tif err := decode(e.Field(i), src); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// .Kind()は、型の種類を返す\n\t\t// reflect.Structは、構造体を表す\n\t\tif f.Type.Kind() == reflect.Struct {\n\t\t\tif err := decode(e.Field(i), src); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// .Tag.Get()は、タグの値を返す\n\t\tkey := f.Tag.Get(\"map\")\n\t\tif key == \"\" {\n\t\t\tkey = f.Name\n\t\t}\n\n\t\t// 元データになければスキップ\n\t\tsv, ok := src[key]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\t// フィールドの型を取得\n\t\tvar k reflect.Kind\n\t\tvar isP bool\n\t\tif f.Type.Kind() != reflect.Ptr {\n\t\t\tk = f.Type.Kind()\n\t\t} else {\n\t\t\tk = f.Type.Elem().Kind()\n\t\t\t// ポインターのポインターは無視\n\t\t\tif k == reflect.Ptr {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tisP = true\n\t\t}\n\t\tswitch k {\n\t\tcase reflect.String:\n\t\t\tif isP {\n\t\t\t\t// .Field.Set()は、フィールドの値を設定する\n\t\t\t\te.Field(i).Set(reflect.ValueOf(&sv))\n\t\t\t} else {\n\t\t\t\t// .Field.SetString()は、フィールドの値を文字列で設定する\n\t\t\t\te.Field(i).SetString(sv)\n\t\t\t}\n\t\tcase reflect.Bool:\n\t\t\tb, err := strconv.ParseBool(sv)\n\t\t\tif err == nil {\n\t\t\t\tif isP {\n\t\t\t\t\te.Field(i).Set(reflect.ValueOf(&b))\n\t\t\t\t} else {\n\t\t\t\t\te.Field(i).SetBool(b)\n\t\t\t\t}\n\t\t\t}\n\t\tcase reflect.Int:\n\t\t\tn64, err := strconv.ParseInt(sv, 10, 64)\n\t\t\tif err == nil {\n\t\t\t\tif isP {\n\t\t\t\t\tn := int(n64)\n\t\t\t\t\te.Field(i).Set(reflect.ValueOf(&n))\n\t\t\t\t} else {\n\t\t\t\t\te.Field(i).SetInt(n64)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n```\n\n### 空の構造体を使ってゴルーチン間での通知を行う\n\n- `make(chan struct{})` は、空の構造体のチャンネルを作成する\n- `go func()` でゴルーチンを作成する\n- `<- struct{}{}` で、チャンネルに値を送信する\n- `<-ch` で、チャンネルから値を受信する\n\n```go\nfunc PrintCh() {\n\t// make(chan struct{})は、空の構造体のチャネルを作成する\n\twait := make(chan struct{})\n\t\n\t// go func()でゴルーチンを作成する\n\tgo func() {\n\t\t// 何かの処理\n\t\tfmt.Println(\"送信\")\n\t\t\n\t\t// wait <- struct{}{}で、空の構造体を送信する\n\t\twait <- struct{}{}\n\t}()\n\tfmt.Println(\"受信待ち\")\n\t\n\t// <-waitで、空の構造体を受信する\n\t<-wait\n\t\n\tfmt.Println(\"受信\")\n}\n\n// 受信待ち\n// 送信\n// 受信\n```\n\n### 構造体のメモリ割り当てを高速化\n\n```go\n// sync.Poolを使ってメモリの再利用を行う\nvar pool = sync.Pool{\n\t// New()は、sync.Poolに値がない場合に呼ばれる\n\tNew: func() interface{} {\n\t\treturn &BigStruct{}\n\t},\n}\n\nfunc main() {\n\t// sync.Poolから値を取得する\n    bigStruct := pool.Get().(*BigStruct)\n    // 使い終わったら、sync.Poolに戻す\n    defer pool.Put(bigStruct)\n}\n```",
      "body_updated_at": "2023-01-22"
    }
  ]
}