---
title: "Vue 3.5 アップデートについて"
emoji: "🦁"
type: "tech"
topics: ["Vue", "JavaScript", "フロントエンド"]
published: false
---

## はじめに

2024年9月1日に Vue 3.5 がリリースされました。この記事では、Vue 3.5 の主な機能改善・追加とその背景について解説します。

https://blog.vuejs.org/posts/vue-3-5

## 主な機能改善・追加

1. **Reactive Props Destructure の安定化**
2. **SSRの改善**
   - Lazy Hydration
   - `useId()`
   - `data-allow-mismatch`
3. **Custom Elements の改良**
4. **その他の機能追加**
   - `useTemplateRef()`
   - Deferred Teleport
   - `onWatcherCleanup()`
5. **Reactivity System の改善**によるパフォーマンス向上

## 1. Reactive Props Destructure の安定化

`<script setup>` 内で `defineProps` から分割代入された変数が自動的にリアクティブになる機能が追加されました。これにより、コードがより簡潔になり、可読性が向上します。

より詳細な内部実装を知りたい方は以下の記事を参照してください。

https://zenn.dev/comm_vue_nuxt/articles/reactive-props-destructure

### RFC

https://github.com/vuejs/rfcs/discussions/502

### 使用例

#### Vue 3.5 以前：

```vue
<script setup lang="ts">
import { computed } from 'vue'

const props = withDefaults(defineProps<{
  count?: number
}>(), {
  count: 0
})

const double = computed(() => props.count * 2)
</script>

<template>
  <div>Count: {{ props.count }}</div>
  <div>Double: {{ double }}</div>
</template>
```

#### Vue 3.5 以降：

```vue
<script setup lang="ts">
import { computed } from 'vue'

const { count = 0 } = defineProps<{
  count?: number
}>()

const double = computed(() => count * 2)
</script>

<template>
  <div>Count: {{ count }}</div>
  <div>Double: {{ double }}</div>
</template>
```

この新しい書き方では、`withDefaults` を使用せずにデフォルト値を設定できるようになりました。また、プロパティへのアクセスが直接的になり、コードの可読性が向上しています。

### 内部的な動作の変化

Vue 3.5の新機能により、コンパイル後のコードにも変更が加えられています。以下に、コンパイル前後のコードの違いを示します。

#### Reactive Props Destructure 以前（コンパイル後）：

```js
const __sfc__ = /*#__PURE__*/_defineComponent({
  // ...
  setup(__props, { expose: __expose }) {
    __expose();

    const props = __props

    const double = computed(() => props.count * 2)

    const __returned__ = { props, double }
    // ...
    return __returned__
  }
});
```

#### Reactive Props Destructure 以降（コンパイル後）：

```js
const __sfc__ = /*#__PURE__*/_defineComponent({
  // ...
  props: {
    count: { type: Number, required: false, default: 0 }
  },
  setup(__props, { expose: __expose }) {
    __expose();

    const double = computed(() => __props.count * 2)

    const __returned__ = { double }
    // ...
    return __returned__
  }
});
```

この変更により、プロパティのデフォルト値がコンポーネントの `props` オプション内で直接定義されるようになり、`setup` 関数内でのプロパティの取り扱いが簡略化されています。

ただし、RFCで言及されている通り、`props` と通常の変数を視覚的に区別するのが難しくなっているため、`@vue/language-tools 2.1` 以降では、オプトイン設定でインレイヒント（inlay hints）を有効にできるようになりました。

```vue
<script setup lang="ts">
import { defineProps } from 'vue'

const { count = 0, msg = 'hello' } = defineProps<{
  count?: number
  message?: string
}>()

// props.count と props.msg の両方がインレイヒントでハイライトされる
console.log(count, msg)
</script>
```

## 2. SSRの改善

### Lazy Hydration

Lazy Hydration は、コンポーネントのハイドレーション（クライアントサイドでの動的な機能の復元）を遅延させる機能です。これにより、初期ページロードのパフォーマンスを向上させることができます。

Vue 3.5 では、以下の Lazy Hydration 戦略が導入されました：

1. **Hydrate on Idle (アイドル時にハイドレーション)**
   - `requestIdleCallback` を使用して、ブラウザがアイドル状態のときにコンポーネントをハイドレーションします。
   
   ```javascript
   import { defineAsyncComponent, hydrateOnIdle } from 'vue'

   const AsyncComp = defineAsyncComponent({
     loader: () => import('./HeavyComponent.vue'),
     hydrate: hydrateOnIdle(5000) // 最大5秒待機
   })
   ```

2. **Hydrate on Visible (表示時にハイドレーション)**
   - `IntersectionObserver` を使用して、コンポーネントが画面に表示されたときにハイドレーションします。
   
   ```javascript
   import { defineAsyncComponent, hydrateOnVisible } from 'vue'

   const AsyncComp = defineAsyncComponent({
     loader: () => import('./LazyLoadedComponent.vue'),
     hydrate: hydrateOnVisible({ rootMargin: '200px' })
   })
   ```

3. **Hydrate on Media Query (メディアクエリ一致時にハイドレーション)**
   - 指定されたメディアクエリが一致したときにコンポーネントをハイドレーションします。
   
   ```javascript
   import { defineAsyncComponent, hydrateOnMediaQuery } from 'vue'

   const MobileComp = defineAsyncComponent({
     loader: () => import('./MobileComponent.vue'),
     hydrate: hydrateOnMediaQuery('(max-width: 768px)')
   })
   ```

4. **Hydrate on Interaction (インタラクション時にハイドレーション)**
   - 指定されたイベント（クリックなど）が発生したときにコンポーネントをハイドレーションします。
   
   ```javascript
   import { defineAsyncComponent, hydrateOnInteraction } from 'vue'

   const InteractiveComp = defineAsyncComponent({
     loader: () => import('./InteractiveComponent.vue'),
     hydrate: hydrateOnInteraction(['click', 'mouseover'])
   })
   ```

5. **Custom Strategy (カスタム戦略)**
   - 独自のハイドレーション戦略を定義できます。
   
   ```javascript
   import { defineAsyncComponent, type HydrationStrategy } from 'vue'

   const customStrategy: HydrationStrategy = (hydrate, forEachElement) => {
     let shouldHydrate = false
     forEachElement(el => {
       // カスタムロジックを実装
       if (someCondition(el)) {
         shouldHydrate = true
       }
     })
     if (shouldHydrate) {
       hydrate()
     }
     return () => {
       // 必要に応じてクリーンアップロジックを実装
     }
   }

   const CustomComp = defineAsyncComponent({
     loader: () => import('./CustomComponent.vue'),
     hydrate: customStrategy
   })
   ```

これらの戦略を適切に使用することで、アプリケーションのパフォーマンスを最適化し、必要なときにのみコンポーネントをハイドレーションすることができます。

### useId()

`useId()` は、Vue 3.5 で導入された新しいコンポジション API で、React の `useId` と類似した機能を提供します。このAPIは、フォーム要素やアクセシビリティ属性に使用できるユニークなIDを生成します。

使用例：

```vue
<script setup>
import { useId } from 'vue'

const id = useId()
</script>

<template>
  <form>
    <label :for="id">Name:</label>
    <input :id="id" type="text" />
  </form>
</template>
```

コンパイル後の出力（一部抜粋）：

```js
setup(__props, { expose: __expose }) {
  __expose();
  const id = useId()
  const __returned__ = { id, useId }
  Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
  return __returned__
}

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock("form", null, [
    _createElementVNode("label", { for: $setup.id }, "Name:", 8 /* PROPS */, _hoisted_1),
    _createElementVNode("input", {
      id: $setup.id,
      type: "text"
    }, null, 8 /* PROPS */, _hoisted_2)
  ]))
}
```

### data-allow-mismatch

`data-allow-mismatch` 属性は、サーバーサイドレンダリング（SSR）とクライアントサイドのハイドレーションの間に発生する可能性のある不一致警告を抑制します。

使用例：

```html
<span data-allow-mismatch>{{ data.toLocaleString() }}</span>
```

また、この属性に値を指定することで、許可する不一致のタイプを制限することもできます：

1. `text`: テキストコンテンツの不一致を許可
2. `children`: 子コンテンツの不一致を許可
3. `class`: クラスの不一致を許可
4. `style`: スタイルの不一致を許可
5. `attribute`: 属性の不一致を許可

## 3. Custom Elements の改良

Vue 3.5 では、カスタム要素（Custom Elements）の機能が大幅に改善されました。

### 主な改善点

1. **アプリケーション設定の柔軟性向上**
   - `configureApp` オプションにより、カスタム要素内で Vue アプリケーションの詳細な設定が可能になりました。

2. **新 API の追加**
   - `useHost()`: ホスト要素（カスタム要素自体）にアクセスするための関数
   - `useShadowRoot()`: シャドウルートにアクセスするための関数
   - `this.$host`: コンポーネント内でホスト要素にアクセスするためのプロパティ

3. **`shadowRoot` オプションの追加**
   - `shadowRoot: false` オプションを使用することで、シャドウ DOM を使用せずにカスタム要素をマウントできるようになりました。

4. **セキュリティ強化：nonce サポート**
   - `nonce` オプションの導入により、カスタム要素によって注入される `<style>` タグに nonce を付与できるようになりました。

### 使用例

```js
import MyElement from './MyElement.ce.vue'

defineCustomElement(MyElement, {
  shadowRoot: false,  // シャドウDOMを使用しない
  nonce: 'xxx',
  configureApp(app) {
    app.config.errorHandler = // エラーハンドラーの設定
  }
})
```

## 4. その他の機能追加

### useTemplateRef()

`useTemplateRef()` を使ってテンプレート参照を取得する新しい方法が導入されました。これにより、動的に変更される ID への `ref` バインディングがサポートされるようになりました。

使用例：

```vue
<script setup>
import { useTemplateRef } from 'vue'

const inputRef = useTemplateRef('input')
</script>

<template>
  <input ref="input">
</template>
```

### Deferred Teleport

Deferred Teleport の機能については、本文中に詳細な説明がありませんでした。この機能の詳細と使用例を追加することで、記事の完全性が向上するでしょう。

### onWatcherCleanup()

`onWatcherCleanup()` の機能についても、本文中に詳細な説明がありませんでした。この機能の詳細と使用例を追加することで、記事の完全性が向上するでしょう。

## 5. Reactivity System の改善

Reactivity System の改善によるパフォーマンス向上について、本文中に詳細な説明がありませんでした。この改善の具体的な内容と、それによってもたらされるパフォーマンス向上の詳細を追加することで、記事の価値が高まるでしょう。