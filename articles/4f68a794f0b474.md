---
title: "Vue 3.5 アップデートについて"
emoji: "🦁"
type: "tech"
topics: ["Vue", "JavaScript", "フロントエンド"]
published: false
---

# はじめに

2024年9月1日に Vue 3.5 がリリースされました。

この記事では、Vue 3.5 の主な機能改善・追加とその背景について解説します。

https://blog.vuejs.org/posts/vue-3-5

## 主な機能改善・追加

1. **Reactive Props Destructure の安定化**
2. **SSRの改善**
   - `Lazy Hydration`
   - `useId()`
   - `data-allow-mismatch`
3. **Custom Elements Improvements の改良**
4. **その他の機能追加**
   - `useTemplateRef()`
   - `Deferred Teleport`
   - `onWatcherCleanup()`
5. **Reactivity System の改善**によるパフォーマンス向上

## Reactive Props Destructure の安定化

`<script setup>` 内で `defineProps` から分割代入された変数が自動的にリアクティブになる機能が追加されました。これにより、コードがより簡潔になり、可読性が向上します。

より詳細な内部実装を知りたい方は以下の記事を参照してください。

https://zenn.dev/comm_vue_nuxt/articles/reactive-props-destructure

### RFC

https://github.com/vuejs/rfcs/discussions/502

### 使用例

#### 以前の書き方：

```vue
<script setup lang="ts">
import { computed } from 'vue'

const props = withDefaults(defineProps<{
  count?: number
}>(), {
  count: 0
})

const double = computed(() => props.count * 2)
</script>

<template>
  <div>Count: {{ props.count }}</div>
  <div>Double: {{ double }}</div>
</template>
```

#### Vue 3.5 以降：

```vue
<script setup lang="ts">
import { computed } from 'vue'

const { count = 0 } = defineProps<{
  count?: number
}>()

const double = computed(() => count * 2)
</script>

<template>
  <div>Count: {{ count }}</div>
  <div>Double: {{ double }}</div>
</template>
```

この新しい書き方では、`withDefaults` を使用せずにデフォルト値を設定できるようになりました。また、プロパティへのアクセスが直接的になり、コードの可読性が向上しています。

### 内部的な動作の変化

Vue 3.5の新機能により、コンパイル後のコードにも変更が加えられています。以下に、コンパイル前後のコードの違いを示します。

#### Reactive Props Destructure 以前

入力：

```vue
<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  count?: number
}>()

const double = computed(() => props.count * 2)
</script>

<template>
  <div>Count: {{ count }}</div>
  <div>Double: {{ double }}</div>
</template>
```

出力（一部抜粋）：

```js
const __sfc__ = /*#__PURE__*/_defineComponent({
  // ...
  setup(__props, { expose: __expose }) {
    __expose();

    const props = __props

    const double = computed(() => props.count * 2)

    const __returned__ = { props, double }
    // ...
    return __returned__
  }
});
```

#### Reactive Props Destructure 以降

入力：

```vue
<script setup lang="ts">
import { computed } from 'vue'

const { count = 0 } = defineProps<{
  count?: number
}>()

const double = computed(() => count * 2)
</script>

<template>
  <div>Count: {{ count }}</div>
  <div>Double: {{ double }}</div>
</template>
```

出力（一部抜粋）：

```js
const __sfc__ = /*#__PURE__*/_defineComponent({
  // ...
  props: {
    count: { type: Number, required: false, default: 0 }
  },
  setup(__props, { expose: __expose }) {
    __expose();

    const double = computed(() => __props.count * 2)

    const __returned__ = { double }
    // ...
    return __returned__
  }
});
```

この変更により、プロパティのデフォルト値がコンポーネントの `props` オプション内で直接定義されるようになり、`setup` 関数内でのプロパティの取り扱いが簡略化されています。

ただし、RFCで言及されている通り、`props` と通常の変数を視覚的に区別するのが難しくなっているため、`@vue/language-tools 2.1` 以降では、オプトイン設定でインレイヒント（inlay hints）を有効にできるようになりました。

```vue
<script setup lang="ts">
import { defineProps } from 'vue'

const { count = 0, msg = 'hello' } = defineProps<{
  count?: number
  message?: string
}>()

// props.count と props.msg の両方がインレイヒントでハイライトされる
console.log(count, msg)
</script>
```

## SSRの改善

### Lazy Hydration

https://github.com/vuejs/core/pull/11530

https://github.com/vuejs/core/pull/11458 

`hydrate` オプションを使用して、ハイドレーションのタイミングを制御できるようになりました。

1. Hydrate on Idle

`requestIdleCallback` を使用して、ブラウザのアイドル時間にハイドレーションを行います。

```vue
<template>
  <AsyncComp />
</template>

<script setup>
import { defineAsyncComponent, hydrateOnIdle } from 'vue'

const AsyncComp = defineAsyncComponent({
  loader: () => import('./HeavyComponent.vue'),
  hydrate: hydrateOnIdle(5000) // 最大5秒待機
})
</script>
```

2. Hydrate on Visible

`IntersectionObserver` を使用して、要素が表示されたときにハイドレーションを行います。

```vue
<template>
  <div class="long-page">
    <div v-for="i in 20" :key="i" class="spacer">Scroll down...</div>
    <AsyncComp />
  </div>
</template>

<script setup>
import { defineAsyncComponent, hydrateOnVisible } from 'vue'

const AsyncComp = defineAsyncComponent({
  loader: () => import('./FooterComponent.vue'),
  hydrate: hydrateOnVisible({ rootMargin: '200px' })
})
</script>

<style scoped>
.long-page {
  height: 2000px;
}
.spacer {
  height: 100px;
}
</style>
```

3. Hydrate on Media Query

指定されたメディアクエリに一致したときにハイドレーションを行います。


```vue
<template>
  <div>
    <AsyncDesktopComp v-if="!isMobile" />
    <AsyncMobileComp v-else />
  </div>
</template>

<script setup>
import { defineAsyncComponent, hydrateOnMediaQuery, ref, onMounted } from 'vue'

const isMobile = ref(false)

const AsyncDesktopComp = defineAsyncComponent({
  loader: () => import('./DesktopComponent.vue'),
  hydrate: hydrateOnMediaQuery('(min-width:501px)')
})

const AsyncMobileComp = defineAsyncComponent({
  loader: () => import('./MobileComponent.vue'),
  hydrate: hydrateOnMediaQuery('(max-width:500px)')
})

onMounted(() => {
  isMobile.value = window.innerWidth <= 500
  window.addEventListener('resize', () => {
    isMobile.value = window.innerWidth <= 500
  })
})
</script>
```

4. Hydrate on Interaction


指定されたイベントがコンポーネント要素で発生したときにハイドレーションを行います。

```vue
<template>
  <AsyncButton>Click me</AsyncButton>
</template>

<script setup>
import { defineAsyncComponent, hydrateOnInteraction } from 'vue'

const AsyncButton = defineAsyncComponent({
  loader: () => import('./InteractiveButton.vue'),
  hydrate: hydrateOnInteraction(['mouseover', 'focus'])
})
</script>
```

カスタムのハイドレーション戦略を定義することも可能です

```vue
<script setup>
import { defineAsyncComponent, type HydrationStrategy } from 'vue'

const myStrategy: HydrationStrategy = (hydrate, forEachElement) => {
  // forEachElement is a helper to iterate through all the root elememts
  // in the component's non-hydrated DOM, since the root can be a fragment
  // instead of a single element
  forEachElement(el => {
    // ...
  })
  // call `hydrate` when ready
  hydrate()
  return () => {
    // return a teardown function if needed
  }
}

const AsyncComp = defineAsyncComponent({
  loader: () => import('./Comp.vue'),
  hydrate: myStrategy
})
</script>
```

### useId()


### data-allow-mismatch


## Custom Elements Improvements の改良


## その他の機能追加

### useTemplateRef()


### Deferred Teleport


### onWatcherCleanup()


## Reactivity System の改善によるパフォーマンス向上

Vue 3.5では、リアクティビティシステムの内部実装が最適化され、全体的なパフォーマンスが向上しました。これにより、特に大規模なアプリケーションでより高速な動作が期待できます。

## まとめ

Vue 3.5は、開発者の生産性を向上させる多くの機能改善と追加を含んでいます。Reactive Props Destructureの安定化、SSRの改善、Custom Elementsの改良などにより、より効率的かつ柔軟なアプリケーション開発が可能になりました。また、パフォーマンスの向上により、ユーザー体験もさらに向上することが期待できます。

これらの新機能を活用することで、Vue.jsを使用したアプリケーション開発がさらに快適になるでしょう。
